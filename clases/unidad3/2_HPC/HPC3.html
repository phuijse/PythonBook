
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3. Optimizando código Python &#8212; INFO147 Computación científica con Python</title>
    
  <link rel="stylesheet" href="../../../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../../../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../../../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/sphinx-book-theme.c441f2ba0852f4cabcb80105e3a46ae6.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/togglebutton.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/translations.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../../_static/sphinx-book-theme.7d483ff0a819d6edff12ce0b1ead3928.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../../_static/sphinx-thebe.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <link rel="index" title="Índice" href="../../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../../search.html" />
    <link rel="next" title="4. Acelerando Python con Cython" href="HPC4.html" />
    <link rel="prev" title="2. Profiling" href="HPC2.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../../../index.html">
  
  <img src="../../../_static/logo.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">INFO147 Computación científica con Python</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Buscar este libro ..." aria-label="Buscar este libro ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <p class="caption collapsible-parent">
 <span class="caption-text">
  Manipulación de datos
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../../unidad1/01_introduccion.html">
   1. Introducción: Computación científica y ciencia de datos
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../unidad1/02_ambientes_virtuales.html">
   2. Ambientes virtuales de Python
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../unidad1/04_jupyter_y_ipython.html">
   3. Jupyter y IPython
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../unidad1/05_numpy.html">
   4. Arreglos y operaciones vectoriales con NumPy
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../unidad1/06_matplotlib.html">
   5. Visualización de datos usando Matplotlib
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../unidad1/07_pandas_b%C3%A1sico.html">
   6. Procesamiento de datos con
   <em>
    pandas
   </em>
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../unidad1/08_pandas_avanzado.html">
   7. Exploración y manipulación de datos con
   <code class="docutils literal notranslate">
    <span class="pre">
     pandas
    </span>
   </code>
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Computación científica
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../../unidad2/1_linearalgebra/1_linear_algebra.html">
   1. Algebra lineal con NumPy
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../unidad2/1_linearalgebra/2_linear_regression.html">
   2. Regresión lineal, Sobreajuste y Validación
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../unidad2/2_calculus/optimization.html">
   3. Optimización matemática
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../unidad2/3_statistics/stats1.html">
   4. Estadística: Fundamentos
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../unidad2/3_statistics/stats2.html">
   5. Estadística descriptiva
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../unidad2/3_statistics/stats3.html">
   6. Estadística inferencial
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Aprendizaje de máquinas
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../1_ML/ML1.html">
   1. Machine Learning: Conceptos clave
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../1_ML/ML2.html">
   2. Aprendizaje supervisado: Clasificación
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../1_ML/ML3.html">
   3. Aprendizaje no supervisado
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Computación de alto rendimiento
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="HPC1.html">
   1. Introducción: Python y  Rendimiento
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="HPC2.html">
   2. Profiling
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   3. Optimizando código Python
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="HPC4.html">
   4. Acelerando Python con Cython
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="HPC5.html">
   5. Computación paralela en Python
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Anexos
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../../unidad1/00_repaso_python3.html">
   1. Repaso de Python 3
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../unidad1/03_control_de_versiones.html">
   2. Control de versiones
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../unidad1/10_pandas_anexos.html">
   3. Pandas: Tópicos extra
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../unidad1/09_interfaces_de_usuario.html">
   4. Interfaces de usuario en Jupyter con
   <code class="docutils literal notranslate">
    <span class="pre">
     ipywidgets
    </span>
   </code>
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../unidad1/11_ipython_display.html">
   5. Módulo
   <code class="docutils literal notranslate">
    <span class="pre">
     IPython.display
    </span>
   </code>
  </a>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Navegación de palanca" aria-controls="site-navigation"
                title="Navegación de palanca" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Descarga esta pagina"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../../_sources/clases/unidad3/2_HPC/HPC3.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Descargar archivo fuente" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Imprimir en PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->


            <!-- Full screen (wrap in <a> to have style consistency -->
            <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                    data-placement="bottom" onclick="toggleFullScreen()" aria-label="Modo de pantalla completa"
                    title="Modo de pantalla completa"><i
                        class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/magister-informatica-uach/INFO147/master?urlpath=tree/clases/unidad3/2_HPC/HPC3.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Lanzamiento Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../../../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i>
            Contenido
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#conocer-el-lenguaje-para-ganar-eficiencia">
   3.1. Conocer el lenguaje para ganar eficiencia
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#evita-usar-for-siempre-que-se-pueda-en-favor-de-las-funciones-nativas">
     3.1.1. Evita usar
     <code class="docutils literal notranslate">
      <span class="pre">
       for
      </span>
     </code>
     siempre que se pueda en favor de las funciones nativas
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#no-reinventes-la-rueda-con-las-estructuras-de-datos">
     3.1.2. No reinventes la rueda con las estructuras de datos
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ten-atencion-con-el-overhead-en-funciones">
     3.1.3. Ten atención con el overhead en funciones
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#usa-variables-locales-dentro-de-los-loops">
     3.1.4. Usa variables locales dentro de los loops
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#vectorizacion-computo-basado-en-arreglos-con-numpy">
   3.2. Vectorización: Cómputo basado en arreglos con NumPy
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#reemplazar-ciclo-for-por-operaciones-vectoriales">
     3.2.1. Reemplazar ciclo
     <code class="docutils literal notranslate">
      <span class="pre">
       for
      </span>
     </code>
     por operaciones vectoriales
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#convertir-operaciones-logicas-sobre-arreglos-en-mascaras">
     3.2.2. Convertir operaciones lógicas sobre arreglos en máscaras
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#usa-operaciones-in-place-y-vistas-de-arreglos-para-evitar-copia-extra-de-datos">
     3.2.3. Usa operaciónes
     <em>
      in-place
     </em>
     y vistas de arreglos para evitar copia extra de datos
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#aprovecha-el-broadcasting-automatico-de-numpy">
     3.2.4. Aprovecha el
     <em>
      broadcasting
     </em>
     automático de NumPy
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#utiliza-el-ordenamiento-en-memoria-mas-adecuado-en-cada-caso">
     3.2.5. Utiliza el ordenamiento en memoría más adecuado en cada caso
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#ejemplo-formativo-vectorizando-el-calculo-del-set-de-julia">
   3.3. Ejemplo formativo: Vectorizando el cálculo del “Set de Julia”
  </a>
 </li>
</ul>

        </nav>
        
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">YouTubeVideo</span><span class="p">,</span> <span class="n">Markdown</span><span class="p">,</span> <span class="n">SVG</span><span class="p">,</span> <span class="n">Code</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="n">YouTubeVideo_formato</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">YouTubeVideo</span><span class="p">,</span> <span class="n">modestbranding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disablekb</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                               <span class="n">width</span><span class="o">=</span><span class="mi">640</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">360</span><span class="p">,</span> <span class="n">autoplay</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">rel</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">showinfo</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">matplotlib</span> inline
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="optimizando-codigo-python">
<h1><span class="section-number">3. </span>Optimizando código Python<a class="headerlink" href="#optimizando-codigo-python" title="Enlazar permanentemente con este título">¶</a></h1>
<p>Como ya hemos mencionado <strong>Python</strong> es un lenguaje versátil pero poco eficiente en comparación a lenguajes de bajo nivel (C o Fortran)</p>
<p>Recordemos que <strong>Python</strong> es un lenguaje <strong>interpretado</strong>. Consideremos la operación</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>z = x + y
</pre></div>
</div>
<p>Esta operación sencilla requiere de <font color="red">inferir el tipo</font> de <span class="math notranslate nohighlight">\(x\)</span> e <span class="math notranslate nohighlight">\(y\)</span> antes de sumarlos, luego debe <font color="red">escoger la función “suma” apropiada</font> y finalmente <font color="red">retornar el tipo correcto</font> de z</p>
<p>El costo de las operaciones en rojo se llama <strong>overhead</strong>, y es el <strong>costo extra</strong> de Python versus los lenguajes compilados</p>
<blockquote>
<div><p>Python nos da simpleza al costo de la eficiencia</p>
</div></blockquote>
<p>Sin embargo, existen varias maneras de mejorar la eficiencia de un código escrito en Python. En esta clase veremos tres:</p>
<p>La primera y más fundamental es</p>
<blockquote>
<div><p><strong>Conocer el lenguaje</strong>: Usar la sintaxis y estructuras de Python adecuadamente</p>
</div></blockquote>
<p>Si tenemos un problema basado en arreglos podemos mejorar la eficiencia en varios órdenes de magnitud usando</p>
<blockquote>
<div><p><strong>Vectorización:</strong> Cómputo basado en arreglos con <code class="docutils literal notranslate"><span class="pre">NumPy</span></code></p>
</div></blockquote>
<p>Finalmente, si las estructuras disponibles no son suficientes o si nuestros cálculos no son vectorizables se puede</p>
<blockquote>
<div><p><strong>Conectar con lenguajes de bajo nivel:</strong> Uniendo Python y C con <code class="docutils literal notranslate"><span class="pre">Cython</span></code></p>
</div></blockquote>
<p>En la lección siguiente se verá en detalle este último punto. En esta lección nos concetraremos en los dos primeros.</p>
<div class="section" id="conocer-el-lenguaje-para-ganar-eficiencia">
<h2><span class="section-number">3.1. </span>Conocer el lenguaje para ganar eficiencia<a class="headerlink" href="#conocer-el-lenguaje-para-ganar-eficiencia" title="Enlazar permanentemente con este título">¶</a></h2>
<p><strong>Python</strong> tiene una curva de aprendizaje suave en comparación a lenguajes de más bajo nivel, es decir que sabiendo muy poco de <strong>Python</strong> ya somos capaces de escribir toda clase de rutinas</p>
<p>Esto tiene un efecto secundario negativo en algunas personas y especialmente en aquellos que ya saben otros lenguajes</p>
<blockquote>
<div><p><strong>Grave error:</strong> Usar Python como si fuera C (o otro lenguaje)</p>
</div></blockquote>
<p>Python ofrece una gran cantidad de <a class="reference external" href="https://docs.python.org/3/library/functions.html">funciones</a> y <a class="reference external" href="https://docs.python.org/3/library/index.html">módulos en su librería estándar</a> que son sumamente eficientes. Usar la sintáxis y las <a class="reference external" href="https://docs.python.org/3/tutorial/datastructures.html">estructuras de datos</a> de Python adecuadamente es el primer paso para escribir código eficiente</p>
<blockquote>
<div><p>Tenga siempre presente lo aprendido en su curso de algoritmos y busque en la documentación de Python las estructuras de datos más apropiadas para cada problema</p>
</div></blockquote>
<p>Si necesita repasar sobre algoritmos se recomienda el siguiente material</p>
<ul class="simple">
<li><p>Bibliografía complementaria del curso: <a class="reference external" href="https://effectivepython.com/">Effective Python</a></p></li>
<li><p><a class="reference external" href="https://runestone.academy/runestone/books/published/pythonds/index.html">Tratado de algoritmos y estructuras de datos en Python</a></p></li>
<li><p><a class="reference external" href="https://wiki.python.org/moin/PythonSpeed">Consejos de velocidad en la Python wiki</a></p></li>
<li><p><a class="reference external" href="https://wiki.python.org/moin/TimeComplexity">Complejidad temporal de distintas estructuras de Python</a></p></li>
</ul>
<p>A continuación les dejo algunos consejos generales enfocados a Python</p>
<div class="section" id="evita-usar-for-siempre-que-se-pueda-en-favor-de-las-funciones-nativas">
<h3><span class="section-number">3.1.1. </span>Evita usar <code class="docutils literal notranslate"><span class="pre">for</span></code> siempre que se pueda en favor de las funciones nativas<a class="headerlink" href="#evita-usar-for-siempre-que-se-pueda-en-favor-de-las-funciones-nativas" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Muchas veces podemos evitar usar <code class="docutils literal notranslate"><span class="pre">for</span></code> con la estructura de datos o función adecuada</p>
<p>Para ejemplificar digamos que queremos sumar los valores absolutos de los elementos de una lista</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100000</span><span class="p">)]</span>

<span class="c1"># Suma estilo C </span>
<span class="k">def</span> <span class="nf">suma_abs</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">resultado</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">resultado</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">resultado</span> <span class="o">-=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">resultado</span>

<span class="o">%</span><span class="k">timeit</span> -r5 -n3 suma_abs(x)
<span class="n">suma_abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>17.7 ms ± 1.6 ms per loop (mean ± std. dev. of 5 runs, 3 loops each)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4999950000
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Mejora 1: No es necesario usar un índice, podemos iterar directamente en los elementos</span>
<span class="k">def</span> <span class="nf">suma_abs</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">resultado</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">element</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">resultado</span> <span class="o">+=</span> <span class="n">element</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">resultado</span> <span class="o">-=</span> <span class="n">element</span>
    <span class="k">return</span> <span class="n">resultado</span>

<span class="o">%</span><span class="k">timeit</span> -r5 -n3 suma_abs(x)
<span class="n">suma_abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>8.93 ms ± 163 µs per loop (mean ± std. dev. of 5 runs, 3 loops each)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4999950000
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Mejora 2: Operar como una comprensión de lista y luego usar la función sum de Python</span>
<span class="o">%</span><span class="k">timeit</span> -r5 -n3 sum([x if x&gt; 0 else -x for x in x])
<span class="nb">sum</span><span class="p">([</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span><span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">x</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>7.7 ms ± 1.66 ms per loop (mean ± std. dev. of 5 runs, 3 loops each)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4999950000
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Mejora 3: Usar las funciones sum, map y abs de Python</span>
<span class="o">%</span><span class="k">timeit</span> -r5 -n3 sum(list(map(abs, x)))
<span class="nb">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">abs</span><span class="p">,</span> <span class="n">x</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4.35 ms ± 33.1 µs per loop (mean ± std. dev. of 5 runs, 3 loops each)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4999950000
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="no-reinventes-la-rueda-con-las-estructuras-de-datos">
<h3><span class="section-number">3.1.2. </span>No reinventes la rueda con las estructuras de datos<a class="headerlink" href="#no-reinventes-la-rueda-con-las-estructuras-de-datos" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Verifica si la estructura que necesitas está implementada en Python antes de programarla tu</p>
<p>Como ejemplo digamos que queremos contar la cantidad de elementos de cada tipo en una lista. Podríamos escribir un contador como</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">))</span>

<span class="c1"># Un contador de elementos</span>
<span class="k">def</span> <span class="nf">miCounter</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">element</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">count</span><span class="p">:</span>
            <span class="n">count</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">count</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">+=</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">count</span>

<span class="o">%</span><span class="k">timeit</span> -r7 -n1 miCounter(x2)
<span class="n">miCounter</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4.2 ms ± 454 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{7: 993,
 8: 1009,
 6: 980,
 4: 991,
 2: 1028,
 9: 1054,
 1: 1031,
 5: 964,
 0: 976,
 3: 974}
</pre></div>
</div>
</div>
</div>
<p>Sin embargo, la clase contador ya existe en <code class="docutils literal notranslate"><span class="pre">collections</span></code>, y es mucho más eficiente que la implementación “a mano”</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="o">%</span><span class="k">timeit</span> -r7 -n1 Counter(x2)
<span class="n">Counter</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.37 ms ± 74.3 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Counter({7: 993,
         8: 1009,
         6: 980,
         4: 991,
         2: 1028,
         9: 1054,
         1: 1031,
         5: 964,
         0: 976,
         3: 974})
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="ten-atencion-con-el-overhead-en-funciones">
<h3><span class="section-number">3.1.3. </span>Ten atención con el overhead en funciones<a class="headerlink" href="#ten-atencion-con-el-overhead-en-funciones" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Python tiene un overhead considerable cada vez que se llama una función</p>
<p>Se puede ganar desempeño haciendo <em>inlining</em> de funciones</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cuadradomasuno</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">element</span><span class="o">*</span><span class="n">element</span> <span class="o">+</span> <span class="mi">1</span>

<span class="o">%</span><span class="k">timeit</span> -r7 -n3 [cuadradomasuno(xi) for xi in x]
<span class="c1">#Inlining: escribo la función textualmente en lugar de evaluarla</span>
<span class="o">%</span><span class="k">timeit</span> -r7 -n3 [xi*xi + 1 for xi in x] 
<span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="n">cuadradomasuno</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="n">xi</span><span class="o">*</span><span class="n">xi</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>22.3 ms ± 1.72 ms per loop (mean ± std. dev. of 7 runs, 3 loops each)
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>13.1 ms ± 167 µs per loop (mean ± std. dev. of 7 runs, 3 loops each)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="usa-variables-locales-dentro-de-los-loops">
<h3><span class="section-number">3.1.4. </span>Usa variables locales dentro de los loops<a class="headerlink" href="#usa-variables-locales-dentro-de-los-loops" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Si estamos obligados a usar <code class="docutils literal notranslate"><span class="pre">for</span></code> podemos ganar algo de rendimiento haciendo copias locales de atributos y funciones</p>
<p>Por ejemplo, digamos que queremos crear una lista con todos los elementos de otra lista que cumplen la condición</p>
<div class="math notranslate nohighlight">
\[
\sin(x[i]) &gt; 0 
\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="c1"># iterando sobre la lista</span>
<span class="k">def</span> <span class="nf">sin_pos</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">resultado</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">resultado</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">resultado</span>

<span class="o">%</span><span class="k">timeit</span> -r5 -n3 sin_pos(x)
<span class="n">resultado1</span> <span class="o">=</span> <span class="n">sin_pos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>24.7 ms ± 150 µs per loop (mean ± std. dev. of 5 runs, 3 loops each)
</pre></div>
</div>
</div>
</div>
<p>Así se vería el código si hacemos variables locales para el método <code class="docutils literal notranslate"><span class="pre">append</span></code> y la función <code class="docutils literal notranslate"><span class="pre">sin</span></code></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Mejora: variables locales</span>
<span class="k">def</span> <span class="nf">sin_pos</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">resultado</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">append</span> <span class="o">=</span> <span class="n">resultado</span><span class="o">.</span><span class="n">append</span>
    <span class="n">sin</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sin</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">resultado</span>

<span class="o">%</span><span class="k">timeit</span> -r5 -n3 sin_pos(x)
<span class="n">resultado2</span> <span class="o">=</span> <span class="n">sin_pos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">resultado1</span><span class="p">,</span> <span class="n">resultado2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>18.9 ms ± 872 µs per loop (mean ± std. dev. of 5 runs, 3 loops each)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="vectorizacion-computo-basado-en-arreglos-con-numpy">
<h2><span class="section-number">3.2. </span>Vectorización: Cómputo basado en arreglos con NumPy<a class="headerlink" href="#vectorizacion-computo-basado-en-arreglos-con-numpy" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Consideremos el escenario en que tenemos un arreglo de datos de gran tamaño y queremos hacer una operación sobre cada elemento</p>
<p><strong>Ejemplo:</strong> Dado <span class="math notranslate nohighlight">\(\{x\}_i\)</span> queremos encontrar</p>
<div class="math notranslate nohighlight">
\[
y_i = \frac{1}{1 + e^{-x_i}}, \quad i = 1,2,\ldots, N
\]</div>
<p>Los cómputos de este tipo se catalogan como <em>SIMD</em>: Single Instruction Multiple Data, es decir que estamos haciendo una misma operación para todos los datos</p>
<p>Este problema se puede resolver usando un ciclo <code class="docutils literal notranslate"><span class="pre">for</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">xi</span><span class="p">))</span>
</pre></div>
</div>
<p>Sin embargo, ya sabemos que esto es ineficiente en “Python puro”</p>
<p>No olvidemos que las librerías de cómputo científico vistas en este curso nos ofrecen una mejor alternativa. En particular, <strong>NumPy</strong> nos provee de una estructura de arreglo multidimensional (ndarray) y funciones para operarla que están escritas en C y Fortran. Otras librerías como <strong>Scipy</strong> y <strong>Pandas</strong> se basan en <strong>NumPy</strong></p>
<blockquote>
<div><p>Cuando utilizamos estas librerías estamos usando código compilado en lugar de interpretado</p>
</div></blockquote>
<p>Usando <strong>NumPy</strong> podemos reemplazar un ciclo <code class="docutils literal notranslate"><span class="pre">for</span></code> en problemas <em>SIMD</em> por operaciones que trabajan sobre todo el arreglo, estas sa llaman <strong>operaciones vectoriales</strong></p>
<p>Por ejemplo el código que vimos anteriormente quedaría como (asumiendo que x es una lista)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>NumPy aplica la función exponencial a todo el arreglo x, luego aplica la aritmética (suma y división) a cada elemento del arreglo (broadcasting) y finalmente retorna un nuevo arreglo con el resultado. En general siempre que exista una operación de tipo <em>SIMD</em> podemos mejorar su rendimiento usando</p>
<blockquote>
<div><p><strong>Vectorización:</strong> Reemplazar un bucle/ciclo por operaciones vectoriales de <strong>NumPy</strong></p>
</div></blockquote>
<p>A continuación revisaremos mediante ejemplos como implementar este y otros conceptos para mejorar el rendimiento</p>
<div class="section" id="reemplazar-ciclo-for-por-operaciones-vectoriales">
<h3><span class="section-number">3.2.1. </span>Reemplazar ciclo <code class="docutils literal notranslate"><span class="pre">for</span></code> por operaciones vectoriales<a class="headerlink" href="#reemplazar-ciclo-for-por-operaciones-vectoriales" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Las operaciones vectoriales son <font color="red"> funciones de NumPy</font> de tipo <em>element-wise</em> <font color="red">aplicadas sobre un ndarray</font></p>
<p>Las funciones <em>element-wise</em> son aquellas que actuan sobre todos los elementos del arreglo de forma independiente</p>
<ul class="simple">
<li><p>En la clase de NumPy (unidad 1) revisamos algunos ejemplos: exponenciación, raíces, trigonometrícas, etc</p></li>
<li><p>Las operaciones aritméticas entre ndarrays son por defecto <em>element-wise</em></p></li>
</ul>
<p>Luego si tenemos un problema SIMD escrito con un <code class="docutils literal notranslate"><span class="pre">for</span></code> sobre un conjunto de datos podemos</p>
<ol class="simple">
<li><p>Convertir los datos a ndarray</p></li>
<li><p>Escribir la operación con funciones de NumPy <em>element-wise</em></p></li>
</ol>
<p>y ganar considerablemente en eficiencia de forma directa. Tenga presente que cuando las operaciones de NumPy se ejecutan sobre un ndarray se está usando código compilado</p>
<p>Por ejemplo notemos la diferencia en tiempo de cómputo al hacer aritmética simple</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x_ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span>
<span class="n">x_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x_ndarray</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">operacion_simple</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">resultado</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">append</span> <span class="o">=</span> <span class="n">resultado</span><span class="o">.</span><span class="n">append</span>
    <span class="k">for</span> <span class="n">elemento</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">append</span><span class="p">(</span><span class="n">elemento</span><span class="o">*</span><span class="n">elemento</span> <span class="o">+</span> <span class="n">elemento</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">resultado</span>

<span class="c1"># Operación usando &quot;for con mejoras&quot;</span>
<span class="o">%</span><span class="k">timeit</span> -n3 -r7 operacion_simple(x_list)
<span class="c1"># Operación usando numpy sobre un ndarray</span>
<span class="o">%</span><span class="k">timeit</span> -n3 -r7 x_ndarray*x_ndarray + x_ndarray
<span class="c1"># Comparación entre los resultados</span>
<span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">operacion_simple</span><span class="p">(</span><span class="n">x_list</span><span class="p">),</span> <span class="n">x_ndarray</span><span class="o">*</span><span class="n">x_ndarray</span> <span class="o">+</span> <span class="n">x_ndarray</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>29.8 ms ± 433 µs per loop (mean ± std. dev. of 7 runs, 3 loops each)
202 µs ± 83.2 µs per loop (mean ± std. dev. of 7 runs, 3 loops each)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<p>Notemos que las funciones de NumPy son lentas cuando operan sobre tipos que no son ndarray</p>
<p>Para el ejemplo de <span class="math notranslate nohighlight">\(y_i = (1 + e^{-x_i})^{-1}, \quad i = 1,2,\ldots, N\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>
<span class="c1"># usando list comprehension (similar a un &quot;for mejorado&quot;)</span>
<span class="o">%</span><span class="k">timeit</span> -n3 -r7 [1./(1.+exp(xi)) for xi in x_list]
<span class="c1"># usando numpy sobre una lista</span>
<span class="o">%</span><span class="k">timeit</span> -n3 -r7 1./(1+np.exp(x_list))
<span class="c1"># usando numpy sobre un ndarray</span>
<span class="o">%</span><span class="k">timeit</span> -n3 -r7 1./(1+np.exp(x_ndarray))
<span class="c1"># Comparación entre los resultados</span>
<span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x_ndarray</span><span class="p">)),</span> <span class="p">[</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">exp</span><span class="p">(</span><span class="n">xi</span><span class="p">))</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x_list</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>17.9 ms ± 425 µs per loop (mean ± std. dev. of 7 runs, 3 loops each)
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>11.8 ms ± 95.6 µs per loop (mean ± std. dev. of 7 runs, 3 loops each)
1.67 ms ± 17.6 µs per loop (mean ± std. dev. of 7 runs, 3 loops each)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<p>Las operación sobre ndarray es casi un orden de magnitud más rápida</p>
<p><strong>¿Cómo se explica esto?</strong></p>
<p>Recuerde que una lista puede tener distintos tipos y estar guardada en distintos sectores de memoria. En cambio, el ndarray</p>
<ul class="simple">
<li><p>Tiene un tipo definido</p></li>
<li><p>Está guardado en bloques de memoria contiguos</p></li>
</ul>
<p>Por ende el ndarray tiene un overhead de interpretador mucho menor</p>
<p>Además NumPy está escrito en C/Fortran, hacer un loop en memoría contigua en C es muy eficiente</p>
<p>Finalmente notar que NumPy puede compilarse con librerías de alto desempeño (openblas, MKL) aprovechando mejor las capacidades del hardware (Cache de CPU e instrucciones vectoriales de CPU)</p>
</div>
<div class="section" id="convertir-operaciones-logicas-sobre-arreglos-en-mascaras">
<h3><span class="section-number">3.2.2. </span>Convertir operaciones lógicas sobre arreglos en máscaras<a class="headerlink" href="#convertir-operaciones-logicas-sobre-arreglos-en-mascaras" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Las operaciones lógicas en NumPy también son <em>element-wise</em> (Operaciones booleanas, clase NumPy, unidad 1)</p>
<p>Si queremos recuperar los elementos de un arreglo que cumplan una cierta condición podemos</p>
<ol class="simple">
<li><p>Convertir los datos a ndarray</p></li>
<li><p>Escribir la operación como una máscara booleana de índices</p></li>
</ol>
<p>Para el ejemplo anterior de recuperamos los elementos tal que <span class="math notranslate nohighlight">\(\sin(x_i)&gt;0\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">sin_pos</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">resultado</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">append</span> <span class="o">=</span> <span class="n">resultado</span><span class="o">.</span><span class="n">append</span>
    <span class="n">sin</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sin</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">resultado</span>

<span class="o">%</span><span class="k">timeit</span> -r5 -n3 sin_pos(x_list)

<span class="o">%</span><span class="k">timeit</span> -r5 -n3 x_ndarray[np.sin(x_ndarray) &gt; 0.]

<span class="n">display</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">sin_pos</span><span class="p">(</span><span class="n">x_list</span><span class="p">),</span> <span class="n">x_ndarray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x_ndarray</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>17.6 ms ± 2.39 ms per loop (mean ± std. dev. of 5 runs, 3 loops each)
2.85 ms ± 17.9 µs per loop (mean ± std. dev. of 5 runs, 3 loops each)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="usa-operaciones-in-place-y-vistas-de-arreglos-para-evitar-copia-extra-de-datos">
<h3><span class="section-number">3.2.3. </span>Usa operaciónes <em>in-place</em> y vistas de arreglos para evitar copia extra de datos<a class="headerlink" href="#usa-operaciones-in-place-y-vistas-de-arreglos-para-evitar-copia-extra-de-datos" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Cuando en NumPy hacemos</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>
</pre></div>
</div>
<p>Se crea una copia interna de x*x, y luego x es direccionado a esa nueva copia. La zona de memoria con el valor original es luego eliminada por el <em>garbage-collector</em> de Python</p>
<p>Siempre que no necesitemos el valor original podemos usar operaciones <em>in-place</em> y ganar rendimiento, ya que evitamos la copia y eliminación adicional</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Copia interna y cambio de referencia de x_ndarray </span>
<span class="o">%</span><span class="k">timeit</span> -r10 -n10 x_ndarray = np.zeros(shape=(1000000)); y = x_ndarray*x_ndarray
<span class="c1"># Sin copia interna</span>
<span class="o">%</span><span class="k">timeit</span> -r10 -n10 x_ndarray = np.zeros(shape=(1000000)); x_ndarray *= x_ndarray
<span class="c1"># El resultado es idéntico</span>
<span class="n">x_ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1000000</span><span class="p">))</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x_ndarray</span><span class="o">*</span><span class="n">x_ndarray</span>
<span class="n">x_ndarray</span> <span class="o">*=</span> <span class="n">x_ndarray</span>
<span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">x_ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3.64 ms ± 150 µs per loop (mean ± std. dev. of 10 runs, 10 loops each)
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.67 ms ± 24.2 µs per loop (mean ± std. dev. of 10 runs, 10 loops each)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<p>Sea <span class="math notranslate nohighlight">\(x\)</span> un ndarray, la operación</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span> 
</pre></div>
</div>
<p>es una “vista de x”. Recordar que las “vista de arreglo” no hacen copias en memoria ya que apuntan directamente al arreglo original. Es decir que si modificamos una vista modificamos el original</p>
</div>
<div class="section" id="aprovecha-el-broadcasting-automatico-de-numpy">
<h3><span class="section-number">3.2.4. </span>Aprovecha el <em>broadcasting</em> automático de NumPy<a class="headerlink" href="#aprovecha-el-broadcasting-automatico-de-numpy" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Se pueden hacer operaciones vectorizadas con NumPy entre arreglos con tamaños distintos. En ese caso se aplican las reglas de <em>broadcasting</em> que vimos en la unidad 1 (clase NumPy). El <em>broadcasting</em> automático no hace copias en memoria</p>
<p>Ejemplo 1: Si le sumas una constante a un arreglo 1D, la constante se expande y se suma a cada elemento</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">1000000</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="p">))</span>
<span class="c1"># broadcasting automático</span>
<span class="o">%</span><span class="k">timeit</span> -n10 -r10 x + 1.
<span class="c1"># Agrandando y luego sumando</span>
<span class="o">%</span><span class="k">timeit</span> -n10 -r10 x + np.tile([1], len(x))
<span class="c1"># mismo resultado</span>
<span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>757 µs ± 207 µs per loop (mean ± std. dev. of 10 runs, 10 loops each)
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>8.63 ms ± 61.6 µs per loop (mean ± std. dev. of 10 runs, 10 loops each)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<p>Ejemplo 2: Si le sumas un arreglo 1D a un arreglo 2D, el arreglo 1D se expande en la dimensión que le falta</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span> <span class="mi">1000</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">))</span> <span class="c1"># arreglo de NxM</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="p">))</span> <span class="c1"># arreglo sin dimensión</span>
<span class="n">y_</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="c1"># arreglo de Nx1</span>
<span class="c1"># broadcasting automático</span>
<span class="o">%</span><span class="k">timeit</span> -n10 -r10 x + y_
<span class="n">display</span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y_</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="c1"># Agrandando y luego sumando</span>
<span class="o">%</span><span class="k">timeit</span> -n10 -r10 x + np.tile(y_, (1, x.shape[-1]))
<span class="c1"># mismo resultado</span>
<span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y_</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">y_</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>26.6 ms ± 608 µs per loop (mean ± std. dev. of 10 runs, 10 loops each)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(10000, 1000)
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>72.5 ms ± 405 µs per loop (mean ± std. dev. of 10 runs, 10 loops each)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<p>Ejemplo 3: Si sumas un arreglo 1D fila y un arreglo 1D columna se crea un arreglo 2D</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span> <span class="mi">1000</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="c1"># arreglo columna de Nx1</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">M</span><span class="p">))</span> <span class="c1"># arreglo fila de 1xM</span>
<span class="c1"># broadcasting automático</span>
<span class="o">%</span><span class="k">timeit</span> -n10 -r10 x + y
<span class="n">display</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="c1"># Agrandando y luego sumando</span>
<span class="o">%</span><span class="k">timeit</span> -n10 -r10 np.tile(y, (x.shape[0], 1)) + np.tile(x, (1, y.shape[-1]))
<span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>33.8 ms ± 1.61 ms per loop (mean ± std. dev. of 10 runs, 10 loops each)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(10000, 1000)
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>103 ms ± 6.15 ms per loop (mean ± std. dev. of 10 runs, 10 loops each)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<p>Regla de oro</p>
<blockquote>
<div><p>Las dimensiones de dos arreglos son compatibles con <em>broadcast</em> automático si <strong>son del mismo tamaño</strong> o <strong>una de ellas es igual a uno</strong></p>
</div></blockquote>
</div>
<div class="section" id="utiliza-el-ordenamiento-en-memoria-mas-adecuado-en-cada-caso">
<h3><span class="section-number">3.2.5. </span>Utiliza el ordenamiento en memoría más adecuado en cada caso<a class="headerlink" href="#utiliza-el-ordenamiento-en-memoria-mas-adecuado-en-cada-caso" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Como vimos en la unidad 1 (clase NumPy), los ndarray multidimensionales pueden guardarse en memoria como <em>row-major</em> (filas contiguas) o <em>column-major</em> (columnas contiguas)</p>
<p>Por defecto las matrices en NumPy son <em>row-major</em> pero podemos forzar la contigüidad usando el atributo <code class="docutils literal notranslate"><span class="pre">order</span></code> o trasponiendo (ojo que trasponer crea una copia)</p>
<p>Se puede verificar esto con el atributo <code class="docutils literal notranslate"><span class="pre">flag</span></code> de los ndarray</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="c1"># Verificamos los flags</span>
<span class="n">display</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">flags</span><span class="p">)</span>
<span class="c1"># Así se ve row-major en memoria </span>
<span class="n">display</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
<span class="c1"># Verificamos los flags</span>
<span class="n">dataT</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">T</span>
<span class="n">display</span><span class="p">(</span><span class="n">dataT</span><span class="o">.</span><span class="n">flags</span><span class="p">)</span>
<span class="c1"># Así se ve column-major en memoria</span>
<span class="n">display</span><span class="p">(</span><span class="n">dataT</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[0, 1, 2],
       [3, 4, 5]])
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : False
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([0, 1, 2, 3, 4, 5])
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>  C_CONTIGUOUS : False
  F_CONTIGUOUS : True
  OWNDATA : False
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([0, 3, 1, 4, 2, 5])
</pre></div>
</div>
</div>
</div>
<p>La mayoría de las funciones de NumPy funcionan más rápido en formato <em>row-major</em> (formato C). Pero algunas funciones de scipy (heredadas de Fortran) funcionan más rápido en formato <em>col-major</em> (formato Fortran)</p>
<p>Es recomendable verificar el orden en memoria que espera la función que vas a utilizar</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span> <span class="c1"># (row-major)</span>
<span class="c1"># Sumando una fila</span>
<span class="o">%</span><span class="k">timeit</span> -n100 -r10 np.sum(data[0, :])
<span class="c1"># Sumando todas las filas</span>
<span class="o">%</span><span class="k">timeit</span> -n10 -r10 np.sum(data, axis=1)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>19.5 µs ± 208 ns per loop (mean ± std. dev. of 10 runs, 100 loops each)
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>77.8 ms ± 6.39 ms per loop (mean ± std. dev. of 10 runs, 10 loops each)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Sumando una columna</span>
<span class="o">%</span><span class="k">timeit</span> -n100 -r10 np.sum(data[:, 0])
<span class="c1"># Sumando todas las columnas</span>
<span class="o">%</span><span class="k">timeit</span> -n10 -r10 np.sum(data, axis=0)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>35.8 µs ± 1.97 µs per loop (mean ± std. dev. of 10 runs, 100 loops each)
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>87.7 ms ± 3.77 ms per loop (mean ± std. dev. of 10 runs, 10 loops each)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Sumando todas las columnas de la matriz traspuesta (column major)</span>
<span class="o">%</span><span class="k">timeit</span> -n10 -r10 np.sum(data.T, axis=0)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>65.8 ms ± 972 µs per loop (mean ± std. dev. of 10 runs, 10 loops each)
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="ejemplo-formativo-vectorizando-el-calculo-del-set-de-julia">
<h2><span class="section-number">3.3. </span>Ejemplo formativo: Vectorizando el cálculo del “Set de Julia”<a class="headerlink" href="#ejemplo-formativo-vectorizando-el-calculo-del-set-de-julia" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Consideremos el código en “Python puro” que vimos en la clase de <em>profiling</em></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">zr</span><span class="p">,</span> <span class="n">maxiters</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">cr</span><span class="o">=-</span><span class="mf">0.835</span><span class="p">,</span> <span class="n">ci</span><span class="o">=-</span><span class="mf">0.2321</span><span class="p">):</span>
    <span class="n">nit</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">zi2</span> <span class="o">=</span> <span class="n">zi</span><span class="o">*</span><span class="n">zi</span>
    <span class="n">zr2</span> <span class="o">=</span> <span class="n">zr</span><span class="o">*</span><span class="n">zr</span>
    <span class="k">while</span> <span class="n">zi2</span> <span class="o">+</span> <span class="n">zr2</span> <span class="o">&lt;=</span> <span class="mf">4.</span> <span class="ow">and</span> <span class="n">nit</span> <span class="o">&lt;</span> <span class="n">maxiters</span><span class="p">:</span>
        <span class="n">zi</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">zr</span><span class="o">*</span><span class="n">zi</span> <span class="o">+</span> <span class="n">ci</span>
        <span class="n">zr</span> <span class="o">=</span> <span class="n">zr2</span> <span class="o">-</span> <span class="n">zi2</span> <span class="o">+</span> <span class="n">cr</span>
        <span class="n">zr2</span> <span class="o">=</span> <span class="n">zr</span><span class="o">*</span><span class="n">zr</span>
        <span class="n">zi2</span> <span class="o">=</span> <span class="n">zi</span><span class="o">*</span><span class="n">zi</span>
        <span class="n">nit</span> <span class="o">+=</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">nit</span>
    
<span class="k">def</span> <span class="nf">make_fractal</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">maxiters</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
    <span class="n">image</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">row</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">):</span>
            <span class="n">zi</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">/</span><span class="n">N</span>
            <span class="n">zr</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">+</span> <span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">/</span><span class="n">N</span>
            <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">evaluate</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">zr</span><span class="p">,</span> <span class="n">maxiters</span><span class="p">))</span>
        <span class="n">image</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">image</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">tight_layout</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">make_fractal</span><span class="p">(</span><span class="mi">500</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/HPC3_45_0.png" src="../../../_images/HPC3_45_0.png" />
</div>
</div>
<p>Estudiando el código nos damos cuenta que la función <code class="docutils literal notranslate"><span class="pre">evaluate</span></code> se ejecuta de forma secuencial para cada uno de los 500x1000 píxeles</p>
<p>Si guardamos la imagen y los valores de <span class="math notranslate nohighlight">\(z\)</span> como un <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> podemos actualizar todos los pixeles “al mismo tiempo”</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_fractal_vectorized</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">maxiters</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">zr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Creamos arreglos de 2NxN para zi y zr </span>
    <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">repeats</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">zr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">zr</span><span class="p">,</span> <span class="n">repeats</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">cr</span><span class="p">,</span> <span class="n">ci</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.835</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2321</span>
    <span class="n">nit</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">nit</span> <span class="o">&lt;</span> <span class="n">maxiters</span><span class="p">:</span>
        <span class="n">zr2</span> <span class="o">=</span> <span class="n">zr</span><span class="o">*</span><span class="n">zr</span> <span class="c1"># operaciones vectoriales</span>
        <span class="n">zi2</span> <span class="o">=</span> <span class="n">zi</span><span class="o">*</span><span class="n">zi</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">zr2</span> <span class="o">+</span> <span class="n">zi2</span> <span class="o">&lt;=</span> <span class="mf">4.</span> <span class="c1">#mascara booleana</span>
        <span class="n">image</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">zi</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">zr</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">*</span><span class="n">zi</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">+</span> <span class="n">ci</span>
        <span class="n">zr</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">zr2</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">-</span> <span class="n">zi2</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">+</span>  <span class="n">cr</span>
        <span class="n">nit</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">image</span>

<span class="c1"># Los resultados comparados:</span>
<span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">make_fractal</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span> <span class="n">make_fractal_vectorized</span><span class="p">(</span><span class="mi">500</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<p>El resultado es idéntico al código secuencial en “Python puro”. El tiempo total para calcular el fractal usando el código vectorizado es:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">timeit</span> -r3 -n1 make_fractal_vectorized(500)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>361 ms ± 5.68 ms per loop (mean ± std. dev. of 3 runs, 1 loop each)
</pre></div>
</div>
</div>
</div>
<p>Por otro lado el tiempo total para la rutina original es</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">timeit</span> -r3 -n1 make_fractal(500)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.56 s ± 9.02 ms per loop (mean ± std. dev. of 3 runs, 1 loop each)
</pre></div>
</div>
</div>
</div>
<p>El <em><strong>speed-up</strong></em> es el tiempo de la nueva rutina dividido el tiempo de referencia (rutina secuencial)</p>
<p>¿Cuánto es el <em>speed-up</em> en este caso?</p>
<p><strong>Mejoras propuestas para la rutina vectorizada</strong></p>
<ul class="simple">
<li><p>Usar operaciones <em>inplace</em> para aumentar el rendimiento</p></li>
<li><p>Además:</p>
<ul>
<li><p>En cada iteración del <code class="docutils literal notranslate"><span class="pre">while</span></code> se calcula el cuadrado de todos los <span class="math notranslate nohighlight">\(z\)</span></p></li>
<li><p>Sin embargo, lo más correcto sería calcular los cuadrados solo para los <span class="math notranslate nohighlight">\(z\)</span> que cumplieron con la condición <span class="math notranslate nohighlight">\(|z| &lt; 4\)</span> la iteración anterior</p></li>
<li><p>¿Cuánto <em>speed-up</em> se obtiene si se implementa esta observación?</p></li>
</ul>
</li>
</ul>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./clases/unidad3/2_HPC"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="HPC2.html" title="previous page"><span class="section-number">2. </span>Profiling</a>
    <a class='right-next' id="next-link" href="HPC4.html" title="next page"><span class="section-number">4. </span>Acelerando Python con Cython</a>

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          Por Pablo Huijse Heise<br/>
        
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../../../_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>